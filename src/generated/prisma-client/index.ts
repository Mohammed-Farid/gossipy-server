// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  membership: (where?: MembershipWhereInput) => Promise<boolean>;
  station: (where?: StationWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  vote: (where?: VoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  membership: (where: MembershipWhereUniqueInput) => MembershipNullablePromise;
  memberships: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Membership>;
  membershipsConnection: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MembershipConnectionPromise;
  station: (where: StationWhereUniqueInput) => StationNullablePromise;
  stations: (args?: {
    where?: StationWhereInput;
    orderBy?: StationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Station>;
  stationsConnection: (args?: {
    where?: StationWhereInput;
    orderBy?: StationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StationConnectionPromise;
  topic: (where: TopicWhereUniqueInput) => TopicNullablePromise;
  topics: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Topic>;
  topicsConnection: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopicConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  vote: (where: VoteWhereUniqueInput) => VoteNullablePromise;
  votes: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vote>;
  votesConnection: (args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createMembership: (data: MembershipCreateInput) => MembershipPromise;
  updateMembership: (args: {
    data: MembershipUpdateInput;
    where: MembershipWhereUniqueInput;
  }) => MembershipPromise;
  updateManyMemberships: (args: {
    data: MembershipUpdateManyMutationInput;
    where?: MembershipWhereInput;
  }) => BatchPayloadPromise;
  upsertMembership: (args: {
    where: MembershipWhereUniqueInput;
    create: MembershipCreateInput;
    update: MembershipUpdateInput;
  }) => MembershipPromise;
  deleteMembership: (where: MembershipWhereUniqueInput) => MembershipPromise;
  deleteManyMemberships: (where?: MembershipWhereInput) => BatchPayloadPromise;
  createStation: (data: StationCreateInput) => StationPromise;
  updateStation: (args: {
    data: StationUpdateInput;
    where: StationWhereUniqueInput;
  }) => StationPromise;
  updateManyStations: (args: {
    data: StationUpdateManyMutationInput;
    where?: StationWhereInput;
  }) => BatchPayloadPromise;
  upsertStation: (args: {
    where: StationWhereUniqueInput;
    create: StationCreateInput;
    update: StationUpdateInput;
  }) => StationPromise;
  deleteStation: (where: StationWhereUniqueInput) => StationPromise;
  deleteManyStations: (where?: StationWhereInput) => BatchPayloadPromise;
  createTopic: (data: TopicCreateInput) => TopicPromise;
  updateTopic: (args: {
    data: TopicUpdateInput;
    where: TopicWhereUniqueInput;
  }) => TopicPromise;
  updateManyTopics: (args: {
    data: TopicUpdateManyMutationInput;
    where?: TopicWhereInput;
  }) => BatchPayloadPromise;
  upsertTopic: (args: {
    where: TopicWhereUniqueInput;
    create: TopicCreateInput;
    update: TopicUpdateInput;
  }) => TopicPromise;
  deleteTopic: (where: TopicWhereUniqueInput) => TopicPromise;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVote: (data: VoteCreateInput) => VotePromise;
  updateVote: (args: {
    data: VoteUpdateInput;
    where: VoteWhereUniqueInput;
  }) => VotePromise;
  updateManyVotes: (args: {
    data: VoteUpdateManyMutationInput;
    where?: VoteWhereInput;
  }) => BatchPayloadPromise;
  upsertVote: (args: {
    where: VoteWhereUniqueInput;
    create: VoteCreateInput;
    update: VoteUpdateInput;
  }) => VotePromise;
  deleteVote: (where: VoteWhereUniqueInput) => VotePromise;
  deleteManyVotes: (where?: VoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  membership: (
    where?: MembershipSubscriptionWhereInput
  ) => MembershipSubscriptionPayloadSubscription;
  station: (
    where?: StationSubscriptionWhereInput
  ) => StationSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  vote: (
    where?: VoteSubscriptionWhereInput
  ) => VoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type VoteType = "UPVOTE" | "DOWNVOTE";

export type Role = "FOUNDER" | "ADMIN" | "MODERATOR" | "MEMBER";

export type MembershipState = "PENDING" | "ACTIVE" | "DETACHED" | "BANNED";

export type MembershipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC"
  | "state_ASC"
  | "state_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "identifier_ASC"
  | "identifier_DESC"
  | "description_ASC"
  | "description_DESC"
  | "public_ASC"
  | "public_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "identifier_ASC"
  | "identifier_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MembershipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  station?: Maybe<StationWhereInput>;
  topics_every?: Maybe<TopicWhereInput>;
  topics_some?: Maybe<TopicWhereInput>;
  topics_none?: Maybe<TopicWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  state?: Maybe<MembershipState>;
  state_not?: Maybe<MembershipState>;
  state_in?: Maybe<MembershipState[] | MembershipState>;
  state_not_in?: Maybe<MembershipState[] | MembershipState>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  OR?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  NOT?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  identifier?: Maybe<String>;
  identifier_not?: Maybe<String>;
  identifier_in?: Maybe<String[] | String>;
  identifier_not_in?: Maybe<String[] | String>;
  identifier_lt?: Maybe<String>;
  identifier_lte?: Maybe<String>;
  identifier_gt?: Maybe<String>;
  identifier_gte?: Maybe<String>;
  identifier_contains?: Maybe<String>;
  identifier_not_contains?: Maybe<String>;
  identifier_starts_with?: Maybe<String>;
  identifier_not_starts_with?: Maybe<String>;
  identifier_ends_with?: Maybe<String>;
  identifier_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  memberships_every?: Maybe<MembershipWhereInput>;
  memberships_some?: Maybe<MembershipWhereInput>;
  memberships_none?: Maybe<MembershipWhereInput>;
  topics_every?: Maybe<TopicWhereInput>;
  topics_some?: Maybe<TopicWhereInput>;
  topics_none?: Maybe<TopicWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface TopicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  station?: Maybe<StationWhereInput>;
  membership?: Maybe<MembershipWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  OR?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  NOT?: Maybe<TopicWhereInput[] | TopicWhereInput>;
}

export interface StationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  identifier?: Maybe<String>;
  identifier_not?: Maybe<String>;
  identifier_in?: Maybe<String[] | String>;
  identifier_not_in?: Maybe<String[] | String>;
  identifier_lt?: Maybe<String>;
  identifier_lte?: Maybe<String>;
  identifier_gt?: Maybe<String>;
  identifier_gte?: Maybe<String>;
  identifier_contains?: Maybe<String>;
  identifier_not_contains?: Maybe<String>;
  identifier_starts_with?: Maybe<String>;
  identifier_not_starts_with?: Maybe<String>;
  identifier_ends_with?: Maybe<String>;
  identifier_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  public?: Maybe<Boolean>;
  public_not?: Maybe<Boolean>;
  members_every?: Maybe<MembershipWhereInput>;
  members_some?: Maybe<MembershipWhereInput>;
  members_none?: Maybe<MembershipWhereInput>;
  topics_every?: Maybe<TopicWhereInput>;
  topics_some?: Maybe<TopicWhereInput>;
  topics_none?: Maybe<TopicWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StationWhereInput[] | StationWhereInput>;
  OR?: Maybe<StationWhereInput[] | StationWhereInput>;
  NOT?: Maybe<StationWhereInput[] | StationWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  station?: Maybe<StationWhereInput>;
  membership?: Maybe<MembershipWhereInput>;
  topic?: Maybe<TopicWhereInput>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface VoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<VoteType>;
  type_not?: Maybe<VoteType>;
  type_in?: Maybe<VoteType[] | VoteType>;
  type_not_in?: Maybe<VoteType[] | VoteType>;
  user?: Maybe<UserWhereInput>;
  station?: Maybe<StationWhereInput>;
  topic?: Maybe<TopicWhereInput>;
  comment?: Maybe<CommentWhereInput>;
  membership?: Maybe<MembershipWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  OR?: Maybe<VoteWhereInput[] | VoteWhereInput>;
  NOT?: Maybe<VoteWhereInput[] | VoteWhereInput>;
}

export type MembershipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identifier?: Maybe<String>;
}>;

export type TopicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identifier?: Maybe<String>;
  email?: Maybe<String>;
}>;

export type VoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  station: StationCreateOneWithoutCommentsInput;
  membership: MembershipCreateOneWithoutCommentsInput;
  topic: TopicCreateOneWithoutCommentsInput;
  votes?: Maybe<VoteCreateManyWithoutCommentInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  memberships?: Maybe<MembershipCreateManyWithoutUserInput>;
  topics?: Maybe<TopicCreateManyWithoutUserInput>;
  votes?: Maybe<VoteCreateManyWithoutUserInput>;
}

export interface MembershipCreateManyWithoutUserInput {
  create?: Maybe<
    MembershipCreateWithoutUserInput[] | MembershipCreateWithoutUserInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  comments?: Maybe<CommentCreateManyWithoutMembershipInput>;
  votes?: Maybe<VoteCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationCreateOneWithoutMembersInput {
  create?: Maybe<StationCreateWithoutMembersInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  topics?: Maybe<TopicCreateManyWithoutStationInput>;
  comments?: Maybe<CommentCreateManyWithoutStationInput>;
  votes?: Maybe<VoteCreateManyWithoutStationInput>;
}

export interface TopicCreateManyWithoutStationInput {
  create?: Maybe<
    TopicCreateWithoutStationInput[] | TopicCreateWithoutStationInput
  >;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutStationInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  user: UserCreateOneWithoutTopicsInput;
  membership: MembershipCreateOneWithoutTopicsInput;
  comments?: Maybe<CommentCreateManyWithoutTopicInput>;
  votes?: Maybe<VoteCreateManyWithoutTopicInput>;
}

export interface UserCreateOneWithoutTopicsInput {
  create?: Maybe<UserCreateWithoutTopicsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutTopicsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  memberships?: Maybe<MembershipCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  votes?: Maybe<VoteCreateManyWithoutUserInput>;
}

export interface CommentCreateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  content: String;
  station: StationCreateOneWithoutCommentsInput;
  membership: MembershipCreateOneWithoutCommentsInput;
  topic: TopicCreateOneWithoutCommentsInput;
  votes?: Maybe<VoteCreateManyWithoutCommentInput>;
}

export interface StationCreateOneWithoutCommentsInput {
  create?: Maybe<StationCreateWithoutCommentsInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipCreateManyWithoutStationInput>;
  topics?: Maybe<TopicCreateManyWithoutStationInput>;
  votes?: Maybe<VoteCreateManyWithoutStationInput>;
}

export interface MembershipCreateManyWithoutStationInput {
  create?: Maybe<
    MembershipCreateWithoutStationInput[] | MembershipCreateWithoutStationInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutStationInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  comments?: Maybe<CommentCreateManyWithoutMembershipInput>;
  votes?: Maybe<VoteCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface UserCreateOneWithoutMembershipsInput {
  create?: Maybe<UserCreateWithoutMembershipsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMembershipsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  topics?: Maybe<TopicCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  votes?: Maybe<VoteCreateManyWithoutUserInput>;
}

export interface TopicCreateManyWithoutUserInput {
  create?: Maybe<TopicCreateWithoutUserInput[] | TopicCreateWithoutUserInput>;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  station: StationCreateOneWithoutTopicsInput;
  membership: MembershipCreateOneWithoutTopicsInput;
  comments?: Maybe<CommentCreateManyWithoutTopicInput>;
  votes?: Maybe<VoteCreateManyWithoutTopicInput>;
}

export interface StationCreateOneWithoutTopicsInput {
  create?: Maybe<StationCreateWithoutTopicsInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationCreateWithoutTopicsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipCreateManyWithoutStationInput>;
  comments?: Maybe<CommentCreateManyWithoutStationInput>;
  votes?: Maybe<VoteCreateManyWithoutStationInput>;
}

export interface CommentCreateManyWithoutStationInput {
  create?: Maybe<
    CommentCreateWithoutStationInput[] | CommentCreateWithoutStationInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutStationInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  membership: MembershipCreateOneWithoutCommentsInput;
  topic: TopicCreateOneWithoutCommentsInput;
  votes?: Maybe<VoteCreateManyWithoutCommentInput>;
}

export interface MembershipCreateOneWithoutCommentsInput {
  create?: Maybe<MembershipCreateWithoutCommentsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  votes?: Maybe<VoteCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface TopicCreateManyWithoutMembershipInput {
  create?: Maybe<
    TopicCreateWithoutMembershipInput[] | TopicCreateWithoutMembershipInput
  >;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  user: UserCreateOneWithoutTopicsInput;
  station: StationCreateOneWithoutTopicsInput;
  comments?: Maybe<CommentCreateManyWithoutTopicInput>;
  votes?: Maybe<VoteCreateManyWithoutTopicInput>;
}

export interface CommentCreateManyWithoutTopicInput {
  create?: Maybe<
    CommentCreateWithoutTopicInput[] | CommentCreateWithoutTopicInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutTopicInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  station: StationCreateOneWithoutCommentsInput;
  membership: MembershipCreateOneWithoutCommentsInput;
  votes?: Maybe<VoteCreateManyWithoutCommentInput>;
}

export interface VoteCreateManyWithoutCommentInput {
  create?: Maybe<
    VoteCreateWithoutCommentInput[] | VoteCreateWithoutCommentInput
  >;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutCommentInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  user: UserCreateOneWithoutVotesInput;
  station: StationCreateOneWithoutVotesInput;
  topic: TopicCreateOneWithoutVotesInput;
  membership: MembershipCreateOneWithoutVotesInput;
}

export interface UserCreateOneWithoutVotesInput {
  create?: Maybe<UserCreateWithoutVotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  memberships?: Maybe<MembershipCreateManyWithoutUserInput>;
  topics?: Maybe<TopicCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
}

export interface StationCreateOneWithoutVotesInput {
  create?: Maybe<StationCreateWithoutVotesInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipCreateManyWithoutStationInput>;
  topics?: Maybe<TopicCreateManyWithoutStationInput>;
  comments?: Maybe<CommentCreateManyWithoutStationInput>;
}

export interface TopicCreateOneWithoutVotesInput {
  create?: Maybe<TopicCreateWithoutVotesInput>;
  connect?: Maybe<TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  user: UserCreateOneWithoutTopicsInput;
  station: StationCreateOneWithoutTopicsInput;
  membership: MembershipCreateOneWithoutTopicsInput;
  comments?: Maybe<CommentCreateManyWithoutTopicInput>;
}

export interface MembershipCreateOneWithoutTopicsInput {
  create?: Maybe<MembershipCreateWithoutTopicsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutTopicsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  comments?: Maybe<CommentCreateManyWithoutMembershipInput>;
  votes?: Maybe<VoteCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface CommentCreateManyWithoutMembershipInput {
  create?: Maybe<
    CommentCreateWithoutMembershipInput[] | CommentCreateWithoutMembershipInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  station: StationCreateOneWithoutCommentsInput;
  topic: TopicCreateOneWithoutCommentsInput;
  votes?: Maybe<VoteCreateManyWithoutCommentInput>;
}

export interface TopicCreateOneWithoutCommentsInput {
  create?: Maybe<TopicCreateWithoutCommentsInput>;
  connect?: Maybe<TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  user: UserCreateOneWithoutTopicsInput;
  station: StationCreateOneWithoutTopicsInput;
  membership: MembershipCreateOneWithoutTopicsInput;
  votes?: Maybe<VoteCreateManyWithoutTopicInput>;
}

export interface VoteCreateManyWithoutTopicInput {
  create?: Maybe<VoteCreateWithoutTopicInput[] | VoteCreateWithoutTopicInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutTopicInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  user: UserCreateOneWithoutVotesInput;
  station: StationCreateOneWithoutVotesInput;
  comment?: Maybe<CommentCreateOneWithoutVotesInput>;
  membership: MembershipCreateOneWithoutVotesInput;
}

export interface CommentCreateOneWithoutVotesInput {
  create?: Maybe<CommentCreateWithoutVotesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  station: StationCreateOneWithoutCommentsInput;
  membership: MembershipCreateOneWithoutCommentsInput;
  topic: TopicCreateOneWithoutCommentsInput;
}

export interface MembershipCreateOneWithoutVotesInput {
  create?: Maybe<MembershipCreateWithoutVotesInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutVotesInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  comments?: Maybe<CommentCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface VoteCreateManyWithoutMembershipInput {
  create?: Maybe<
    VoteCreateWithoutMembershipInput[] | VoteCreateWithoutMembershipInput
  >;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  user: UserCreateOneWithoutVotesInput;
  station: StationCreateOneWithoutVotesInput;
  topic: TopicCreateOneWithoutVotesInput;
  comment?: Maybe<CommentCreateOneWithoutVotesInput>;
}

export interface VoteCreateManyWithoutStationInput {
  create?: Maybe<
    VoteCreateWithoutStationInput[] | VoteCreateWithoutStationInput
  >;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutStationInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  user: UserCreateOneWithoutVotesInput;
  topic: TopicCreateOneWithoutVotesInput;
  comment?: Maybe<CommentCreateOneWithoutVotesInput>;
  membership: MembershipCreateOneWithoutVotesInput;
}

export interface VoteCreateManyWithoutUserInput {
  create?: Maybe<VoteCreateWithoutUserInput[] | VoteCreateWithoutUserInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
}

export interface VoteCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  station: StationCreateOneWithoutVotesInput;
  topic: TopicCreateOneWithoutVotesInput;
  comment?: Maybe<CommentCreateOneWithoutVotesInput>;
  membership: MembershipCreateOneWithoutVotesInput;
}

export interface CommentUpdateInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutCommentsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutCommentsInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<VoteUpdateManyWithoutCommentInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutUserInput>;
  topics?: Maybe<TopicUpdateManyWithoutUserInput>;
  votes?: Maybe<VoteUpdateManyWithoutUserInput>;
}

export interface MembershipUpdateManyWithoutUserInput {
  create?: Maybe<
    MembershipCreateWithoutUserInput[] | MembershipCreateWithoutUserInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    | MembershipUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    | MembershipUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipUpdateWithWhereUniqueWithoutUserInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutUserDataInput;
}

export interface MembershipUpdateWithoutUserDataInput {
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  comments?: Maybe<CommentUpdateManyWithoutMembershipInput>;
  votes?: Maybe<VoteUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationUpdateOneRequiredWithoutMembersInput {
  create?: Maybe<StationCreateWithoutMembersInput>;
  update?: Maybe<StationUpdateWithoutMembersDataInput>;
  upsert?: Maybe<StationUpsertWithoutMembersInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  topics?: Maybe<TopicUpdateManyWithoutStationInput>;
  comments?: Maybe<CommentUpdateManyWithoutStationInput>;
  votes?: Maybe<VoteUpdateManyWithoutStationInput>;
}

export interface TopicUpdateManyWithoutStationInput {
  create?: Maybe<
    TopicCreateWithoutStationInput[] | TopicCreateWithoutStationInput
  >;
  delete?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  set?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  disconnect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  update?: Maybe<
    | TopicUpdateWithWhereUniqueWithoutStationInput[]
    | TopicUpdateWithWhereUniqueWithoutStationInput
  >;
  upsert?: Maybe<
    | TopicUpsertWithWhereUniqueWithoutStationInput[]
    | TopicUpsertWithWhereUniqueWithoutStationInput
  >;
  deleteMany?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  updateMany?: Maybe<
    TopicUpdateManyWithWhereNestedInput[] | TopicUpdateManyWithWhereNestedInput
  >;
}

export interface TopicUpdateWithWhereUniqueWithoutStationInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutStationDataInput;
}

export interface TopicUpdateWithoutStationDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutTopicsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
  comments?: Maybe<CommentUpdateManyWithoutTopicInput>;
  votes?: Maybe<VoteUpdateManyWithoutTopicInput>;
}

export interface UserUpdateOneRequiredWithoutTopicsInput {
  create?: Maybe<UserCreateWithoutTopicsInput>;
  update?: Maybe<UserUpdateWithoutTopicsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTopicsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutTopicsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  votes?: Maybe<VoteUpdateManyWithoutUserInput>;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface CommentUpdateWithoutUserDataInput {
  content?: Maybe<String>;
  station?: Maybe<StationUpdateOneRequiredWithoutCommentsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutCommentsInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<VoteUpdateManyWithoutCommentInput>;
}

export interface StationUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<StationCreateWithoutCommentsInput>;
  update?: Maybe<StationUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<StationUpsertWithoutCommentsInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipUpdateManyWithoutStationInput>;
  topics?: Maybe<TopicUpdateManyWithoutStationInput>;
  votes?: Maybe<VoteUpdateManyWithoutStationInput>;
}

export interface MembershipUpdateManyWithoutStationInput {
  create?: Maybe<
    MembershipCreateWithoutStationInput[] | MembershipCreateWithoutStationInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutStationInput[]
    | MembershipUpdateWithWhereUniqueWithoutStationInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutStationInput[]
    | MembershipUpsertWithWhereUniqueWithoutStationInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipUpdateWithWhereUniqueWithoutStationInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutStationDataInput;
}

export interface MembershipUpdateWithoutStationDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  comments?: Maybe<CommentUpdateManyWithoutMembershipInput>;
  votes?: Maybe<VoteUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface UserUpdateOneRequiredWithoutMembershipsInput {
  create?: Maybe<UserCreateWithoutMembershipsInput>;
  update?: Maybe<UserUpdateWithoutMembershipsDataInput>;
  upsert?: Maybe<UserUpsertWithoutMembershipsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMembershipsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  topics?: Maybe<TopicUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  votes?: Maybe<VoteUpdateManyWithoutUserInput>;
}

export interface TopicUpdateManyWithoutUserInput {
  create?: Maybe<TopicCreateWithoutUserInput[] | TopicCreateWithoutUserInput>;
  delete?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  set?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  disconnect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  update?: Maybe<
    | TopicUpdateWithWhereUniqueWithoutUserInput[]
    | TopicUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | TopicUpsertWithWhereUniqueWithoutUserInput[]
    | TopicUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  updateMany?: Maybe<
    TopicUpdateManyWithWhereNestedInput[] | TopicUpdateManyWithWhereNestedInput
  >;
}

export interface TopicUpdateWithWhereUniqueWithoutUserInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutUserDataInput;
}

export interface TopicUpdateWithoutUserDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  station?: Maybe<StationUpdateOneRequiredWithoutTopicsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
  comments?: Maybe<CommentUpdateManyWithoutTopicInput>;
  votes?: Maybe<VoteUpdateManyWithoutTopicInput>;
}

export interface StationUpdateOneRequiredWithoutTopicsInput {
  create?: Maybe<StationCreateWithoutTopicsInput>;
  update?: Maybe<StationUpdateWithoutTopicsDataInput>;
  upsert?: Maybe<StationUpsertWithoutTopicsInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationUpdateWithoutTopicsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipUpdateManyWithoutStationInput>;
  comments?: Maybe<CommentUpdateManyWithoutStationInput>;
  votes?: Maybe<VoteUpdateManyWithoutStationInput>;
}

export interface CommentUpdateManyWithoutStationInput {
  create?: Maybe<
    CommentCreateWithoutStationInput[] | CommentCreateWithoutStationInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutStationInput[]
    | CommentUpdateWithWhereUniqueWithoutStationInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutStationInput[]
    | CommentUpsertWithWhereUniqueWithoutStationInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutStationInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutStationDataInput;
}

export interface CommentUpdateWithoutStationDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutCommentsInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<VoteUpdateManyWithoutCommentInput>;
}

export interface MembershipUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<MembershipCreateWithoutCommentsInput>;
  update?: Maybe<MembershipUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<MembershipUpsertWithoutCommentsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipUpdateWithoutCommentsDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  votes?: Maybe<VoteUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface TopicUpdateManyWithoutMembershipInput {
  create?: Maybe<
    TopicCreateWithoutMembershipInput[] | TopicCreateWithoutMembershipInput
  >;
  delete?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  set?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  disconnect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  update?: Maybe<
    | TopicUpdateWithWhereUniqueWithoutMembershipInput[]
    | TopicUpdateWithWhereUniqueWithoutMembershipInput
  >;
  upsert?: Maybe<
    | TopicUpsertWithWhereUniqueWithoutMembershipInput[]
    | TopicUpsertWithWhereUniqueWithoutMembershipInput
  >;
  deleteMany?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  updateMany?: Maybe<
    TopicUpdateManyWithWhereNestedInput[] | TopicUpdateManyWithWhereNestedInput
  >;
}

export interface TopicUpdateWithWhereUniqueWithoutMembershipInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutMembershipDataInput;
}

export interface TopicUpdateWithoutMembershipDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutTopicsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutTopicsInput>;
  comments?: Maybe<CommentUpdateManyWithoutTopicInput>;
  votes?: Maybe<VoteUpdateManyWithoutTopicInput>;
}

export interface CommentUpdateManyWithoutTopicInput {
  create?: Maybe<
    CommentCreateWithoutTopicInput[] | CommentCreateWithoutTopicInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutTopicInput[]
    | CommentUpdateWithWhereUniqueWithoutTopicInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutTopicInput[]
    | CommentUpsertWithWhereUniqueWithoutTopicInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutTopicInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutTopicDataInput;
}

export interface CommentUpdateWithoutTopicDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutCommentsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<VoteUpdateManyWithoutCommentInput>;
}

export interface VoteUpdateManyWithoutCommentInput {
  create?: Maybe<
    VoteCreateWithoutCommentInput[] | VoteCreateWithoutCommentInput
  >;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutCommentInput[]
    | VoteUpdateWithWhereUniqueWithoutCommentInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutCommentInput[]
    | VoteUpsertWithWhereUniqueWithoutCommentInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  updateMany?: Maybe<
    VoteUpdateManyWithWhereNestedInput[] | VoteUpdateManyWithWhereNestedInput
  >;
}

export interface VoteUpdateWithWhereUniqueWithoutCommentInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutCommentDataInput;
}

export interface VoteUpdateWithoutCommentDataInput {
  type?: Maybe<VoteType>;
  user?: Maybe<UserUpdateOneRequiredWithoutVotesInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutVotesInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutVotesInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutVotesInput>;
}

export interface UserUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<UserCreateWithoutVotesInput>;
  update?: Maybe<UserUpdateWithoutVotesDataInput>;
  upsert?: Maybe<UserUpsertWithoutVotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutVotesDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutUserInput>;
  topics?: Maybe<TopicUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutVotesInput {
  update: UserUpdateWithoutVotesDataInput;
  create: UserCreateWithoutVotesInput;
}

export interface StationUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<StationCreateWithoutVotesInput>;
  update?: Maybe<StationUpdateWithoutVotesDataInput>;
  upsert?: Maybe<StationUpsertWithoutVotesInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationUpdateWithoutVotesDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipUpdateManyWithoutStationInput>;
  topics?: Maybe<TopicUpdateManyWithoutStationInput>;
  comments?: Maybe<CommentUpdateManyWithoutStationInput>;
}

export interface StationUpsertWithoutVotesInput {
  update: StationUpdateWithoutVotesDataInput;
  create: StationCreateWithoutVotesInput;
}

export interface TopicUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<TopicCreateWithoutVotesInput>;
  update?: Maybe<TopicUpdateWithoutVotesDataInput>;
  upsert?: Maybe<TopicUpsertWithoutVotesInput>;
  connect?: Maybe<TopicWhereUniqueInput>;
}

export interface TopicUpdateWithoutVotesDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutTopicsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutTopicsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
  comments?: Maybe<CommentUpdateManyWithoutTopicInput>;
}

export interface MembershipUpdateOneRequiredWithoutTopicsInput {
  create?: Maybe<MembershipCreateWithoutTopicsInput>;
  update?: Maybe<MembershipUpdateWithoutTopicsDataInput>;
  upsert?: Maybe<MembershipUpsertWithoutTopicsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipUpdateWithoutTopicsDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  comments?: Maybe<CommentUpdateManyWithoutMembershipInput>;
  votes?: Maybe<VoteUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface CommentUpdateManyWithoutMembershipInput {
  create?: Maybe<
    CommentCreateWithoutMembershipInput[] | CommentCreateWithoutMembershipInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutMembershipInput[]
    | CommentUpdateWithWhereUniqueWithoutMembershipInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutMembershipInput[]
    | CommentUpsertWithWhereUniqueWithoutMembershipInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutMembershipInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutMembershipDataInput;
}

export interface CommentUpdateWithoutMembershipDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutCommentsInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutCommentsInput>;
  votes?: Maybe<VoteUpdateManyWithoutCommentInput>;
}

export interface TopicUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<TopicCreateWithoutCommentsInput>;
  update?: Maybe<TopicUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<TopicUpsertWithoutCommentsInput>;
  connect?: Maybe<TopicWhereUniqueInput>;
}

export interface TopicUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutTopicsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutTopicsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
  votes?: Maybe<VoteUpdateManyWithoutTopicInput>;
}

export interface VoteUpdateManyWithoutTopicInput {
  create?: Maybe<VoteCreateWithoutTopicInput[] | VoteCreateWithoutTopicInput>;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutTopicInput[]
    | VoteUpdateWithWhereUniqueWithoutTopicInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutTopicInput[]
    | VoteUpsertWithWhereUniqueWithoutTopicInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  updateMany?: Maybe<
    VoteUpdateManyWithWhereNestedInput[] | VoteUpdateManyWithWhereNestedInput
  >;
}

export interface VoteUpdateWithWhereUniqueWithoutTopicInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutTopicDataInput;
}

export interface VoteUpdateWithoutTopicDataInput {
  type?: Maybe<VoteType>;
  user?: Maybe<UserUpdateOneRequiredWithoutVotesInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutVotesInput>;
  comment?: Maybe<CommentUpdateOneWithoutVotesInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutVotesInput>;
}

export interface CommentUpdateOneWithoutVotesInput {
  create?: Maybe<CommentCreateWithoutVotesInput>;
  update?: Maybe<CommentUpdateWithoutVotesDataInput>;
  upsert?: Maybe<CommentUpsertWithoutVotesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface CommentUpdateWithoutVotesDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutCommentsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutCommentsInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutCommentsInput>;
}

export interface CommentUpsertWithoutVotesInput {
  update: CommentUpdateWithoutVotesDataInput;
  create: CommentCreateWithoutVotesInput;
}

export interface MembershipUpdateOneRequiredWithoutVotesInput {
  create?: Maybe<MembershipCreateWithoutVotesInput>;
  update?: Maybe<MembershipUpdateWithoutVotesDataInput>;
  upsert?: Maybe<MembershipUpsertWithoutVotesInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipUpdateWithoutVotesDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  comments?: Maybe<CommentUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpsertWithoutVotesInput {
  update: MembershipUpdateWithoutVotesDataInput;
  create: MembershipCreateWithoutVotesInput;
}

export interface VoteUpsertWithWhereUniqueWithoutTopicInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutTopicDataInput;
  create: VoteCreateWithoutTopicInput;
}

export interface VoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<VoteType>;
  type_not?: Maybe<VoteType>;
  type_in?: Maybe<VoteType[] | VoteType>;
  type_not_in?: Maybe<VoteType[] | VoteType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  OR?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  NOT?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
}

export interface VoteUpdateManyWithWhereNestedInput {
  where: VoteScalarWhereInput;
  data: VoteUpdateManyDataInput;
}

export interface VoteUpdateManyDataInput {
  type?: Maybe<VoteType>;
}

export interface TopicUpsertWithoutCommentsInput {
  update: TopicUpdateWithoutCommentsDataInput;
  create: TopicCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutMembershipInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutMembershipDataInput;
  create: CommentCreateWithoutMembershipInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  content?: Maybe<String>;
}

export interface VoteUpdateManyWithoutMembershipInput {
  create?: Maybe<
    VoteCreateWithoutMembershipInput[] | VoteCreateWithoutMembershipInput
  >;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutMembershipInput[]
    | VoteUpdateWithWhereUniqueWithoutMembershipInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutMembershipInput[]
    | VoteUpsertWithWhereUniqueWithoutMembershipInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  updateMany?: Maybe<
    VoteUpdateManyWithWhereNestedInput[] | VoteUpdateManyWithWhereNestedInput
  >;
}

export interface VoteUpdateWithWhereUniqueWithoutMembershipInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutMembershipDataInput;
}

export interface VoteUpdateWithoutMembershipDataInput {
  type?: Maybe<VoteType>;
  user?: Maybe<UserUpdateOneRequiredWithoutVotesInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutVotesInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutVotesInput>;
  comment?: Maybe<CommentUpdateOneWithoutVotesInput>;
}

export interface VoteUpsertWithWhereUniqueWithoutMembershipInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutMembershipDataInput;
  create: VoteCreateWithoutMembershipInput;
}

export interface MembershipUpsertWithoutTopicsInput {
  update: MembershipUpdateWithoutTopicsDataInput;
  create: MembershipCreateWithoutTopicsInput;
}

export interface TopicUpsertWithoutVotesInput {
  update: TopicUpdateWithoutVotesDataInput;
  create: TopicCreateWithoutVotesInput;
}

export interface VoteUpsertWithWhereUniqueWithoutCommentInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutCommentDataInput;
  create: VoteCreateWithoutCommentInput;
}

export interface CommentUpsertWithWhereUniqueWithoutTopicInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutTopicDataInput;
  create: CommentCreateWithoutTopicInput;
}

export interface TopicUpsertWithWhereUniqueWithoutMembershipInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutMembershipDataInput;
  create: TopicCreateWithoutMembershipInput;
}

export interface TopicScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  OR?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  NOT?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
}

export interface TopicUpdateManyWithWhereNestedInput {
  where: TopicScalarWhereInput;
  data: TopicUpdateManyDataInput;
}

export interface TopicUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface MembershipUpsertWithoutCommentsInput {
  update: MembershipUpdateWithoutCommentsDataInput;
  create: MembershipCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutStationInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutStationDataInput;
  create: CommentCreateWithoutStationInput;
}

export interface VoteUpdateManyWithoutStationInput {
  create?: Maybe<
    VoteCreateWithoutStationInput[] | VoteCreateWithoutStationInput
  >;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutStationInput[]
    | VoteUpdateWithWhereUniqueWithoutStationInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutStationInput[]
    | VoteUpsertWithWhereUniqueWithoutStationInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  updateMany?: Maybe<
    VoteUpdateManyWithWhereNestedInput[] | VoteUpdateManyWithWhereNestedInput
  >;
}

export interface VoteUpdateWithWhereUniqueWithoutStationInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutStationDataInput;
}

export interface VoteUpdateWithoutStationDataInput {
  type?: Maybe<VoteType>;
  user?: Maybe<UserUpdateOneRequiredWithoutVotesInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutVotesInput>;
  comment?: Maybe<CommentUpdateOneWithoutVotesInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutVotesInput>;
}

export interface VoteUpsertWithWhereUniqueWithoutStationInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutStationDataInput;
  create: VoteCreateWithoutStationInput;
}

export interface StationUpsertWithoutTopicsInput {
  update: StationUpdateWithoutTopicsDataInput;
  create: StationCreateWithoutTopicsInput;
}

export interface TopicUpsertWithWhereUniqueWithoutUserInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutUserDataInput;
  create: TopicCreateWithoutUserInput;
}

export interface VoteUpdateManyWithoutUserInput {
  create?: Maybe<VoteCreateWithoutUserInput[] | VoteCreateWithoutUserInput>;
  delete?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  connect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  set?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  disconnect?: Maybe<VoteWhereUniqueInput[] | VoteWhereUniqueInput>;
  update?: Maybe<
    | VoteUpdateWithWhereUniqueWithoutUserInput[]
    | VoteUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | VoteUpsertWithWhereUniqueWithoutUserInput[]
    | VoteUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<VoteScalarWhereInput[] | VoteScalarWhereInput>;
  updateMany?: Maybe<
    VoteUpdateManyWithWhereNestedInput[] | VoteUpdateManyWithWhereNestedInput
  >;
}

export interface VoteUpdateWithWhereUniqueWithoutUserInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutUserDataInput;
}

export interface VoteUpdateWithoutUserDataInput {
  type?: Maybe<VoteType>;
  station?: Maybe<StationUpdateOneRequiredWithoutVotesInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutVotesInput>;
  comment?: Maybe<CommentUpdateOneWithoutVotesInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutVotesInput>;
}

export interface VoteUpsertWithWhereUniqueWithoutUserInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutUserDataInput;
  create: VoteCreateWithoutUserInput;
}

export interface UserUpsertWithoutMembershipsInput {
  update: UserUpdateWithoutMembershipsDataInput;
  create: UserCreateWithoutMembershipsInput;
}

export interface MembershipUpsertWithWhereUniqueWithoutStationInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutStationDataInput;
  create: MembershipCreateWithoutStationInput;
}

export interface MembershipScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  state?: Maybe<MembershipState>;
  state_not?: Maybe<MembershipState>;
  state_in?: Maybe<MembershipState[] | MembershipState>;
  state_not_in?: Maybe<MembershipState[] | MembershipState>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  OR?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  NOT?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
}

export interface MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput;
  data: MembershipUpdateManyDataInput;
}

export interface MembershipUpdateManyDataInput {
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationUpsertWithoutCommentsInput {
  update: StationUpdateWithoutCommentsDataInput;
  create: StationCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface UserUpsertWithoutTopicsInput {
  update: UserUpdateWithoutTopicsDataInput;
  create: UserCreateWithoutTopicsInput;
}

export interface TopicUpsertWithWhereUniqueWithoutStationInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutStationDataInput;
  create: TopicCreateWithoutStationInput;
}

export interface StationUpsertWithoutMembersInput {
  update: StationUpdateWithoutMembersDataInput;
  create: StationCreateWithoutMembersInput;
}

export interface MembershipUpsertWithWhereUniqueWithoutUserInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutUserDataInput;
  create: MembershipCreateWithoutUserInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface CommentUpdateManyMutationInput {
  content?: Maybe<String>;
}

export interface MembershipCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  comments?: Maybe<CommentCreateManyWithoutMembershipInput>;
  votes?: Maybe<VoteCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  comments?: Maybe<CommentUpdateManyWithoutMembershipInput>;
  votes?: Maybe<VoteUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpdateManyMutationInput {
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipCreateManyWithoutStationInput>;
  topics?: Maybe<TopicCreateManyWithoutStationInput>;
  comments?: Maybe<CommentCreateManyWithoutStationInput>;
  votes?: Maybe<VoteCreateManyWithoutStationInput>;
}

export interface StationUpdateInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipUpdateManyWithoutStationInput>;
  topics?: Maybe<TopicUpdateManyWithoutStationInput>;
  comments?: Maybe<CommentUpdateManyWithoutStationInput>;
  votes?: Maybe<VoteUpdateManyWithoutStationInput>;
}

export interface StationUpdateManyMutationInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
}

export interface TopicCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  user: UserCreateOneWithoutTopicsInput;
  station: StationCreateOneWithoutTopicsInput;
  membership: MembershipCreateOneWithoutTopicsInput;
  comments?: Maybe<CommentCreateManyWithoutTopicInput>;
  votes?: Maybe<VoteCreateManyWithoutTopicInput>;
}

export interface TopicUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutTopicsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutTopicsInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
  comments?: Maybe<CommentUpdateManyWithoutTopicInput>;
  votes?: Maybe<VoteUpdateManyWithoutTopicInput>;
}

export interface TopicUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  memberships?: Maybe<MembershipCreateManyWithoutUserInput>;
  topics?: Maybe<TopicCreateManyWithoutUserInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  votes?: Maybe<VoteCreateManyWithoutUserInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutUserInput>;
  topics?: Maybe<TopicUpdateManyWithoutUserInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  votes?: Maybe<VoteUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
}

export interface VoteCreateInput {
  id?: Maybe<ID_Input>;
  type: VoteType;
  user: UserCreateOneWithoutVotesInput;
  station: StationCreateOneWithoutVotesInput;
  topic: TopicCreateOneWithoutVotesInput;
  comment?: Maybe<CommentCreateOneWithoutVotesInput>;
  membership: MembershipCreateOneWithoutVotesInput;
}

export interface VoteUpdateInput {
  type?: Maybe<VoteType>;
  user?: Maybe<UserUpdateOneRequiredWithoutVotesInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutVotesInput>;
  topic?: Maybe<TopicUpdateOneRequiredWithoutVotesInput>;
  comment?: Maybe<CommentUpdateOneWithoutVotesInput>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutVotesInput>;
}

export interface VoteUpdateManyMutationInput {
  type?: Maybe<VoteType>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface MembershipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MembershipWhereInput>;
  AND?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  OR?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
}

export interface StationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StationWhereInput>;
  AND?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
  OR?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
  NOT?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TopicWhereInput>;
  AND?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  OR?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  NOT?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface VoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoteWhereInput>;
  AND?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  OR?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
  NOT?: Maybe<VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Comment {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  topic: <T = TopicPromise>() => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  station: <T = StationSubscription>() => T;
  membership: <T = MembershipSubscription>() => T;
  topic: <T = TopicSubscription>() => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  topic: <T = TopicPromise>() => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  name: String;
  identifier?: String;
  password: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  memberships: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Membership {
  id: ID_Output;
  role: Role;
  state: MembershipState;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MembershipPromise extends Promise<Membership>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MembershipSubscription
  extends Promise<AsyncIterator<Membership>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  station: <T = StationSubscription>() => T;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<AsyncIterator<Role>>;
  state: () => Promise<AsyncIterator<MembershipState>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MembershipNullablePromise
  extends Promise<Membership | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Station {
  id: ID_Output;
  name: String;
  identifier?: String;
  description: String;
  public: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StationPromise extends Promise<Station>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  members: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StationSubscription
  extends Promise<AsyncIterator<Station>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  members: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StationNullablePromise
  extends Promise<Station | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  members: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Topic {
  id: ID_Output;
  title: String;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  station: <T = StationSubscription>() => T;
  membership: <T = MembershipSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TopicNullablePromise
  extends Promise<Topic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  votes: <T = FragmentableArray<Vote>>(args?: {
    where?: VoteWhereInput;
    orderBy?: VoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Vote {
  id: ID_Output;
  type: VoteType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VotePromise extends Promise<Vote>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VoteType>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topic: <T = TopicPromise>() => T;
  comment: <T = CommentPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VoteSubscription
  extends Promise<AsyncIterator<Vote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VoteType>>;
  user: <T = UserSubscription>() => T;
  station: <T = StationSubscription>() => T;
  topic: <T = TopicSubscription>() => T;
  comment: <T = CommentSubscription>() => T;
  membership: <T = MembershipSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VoteNullablePromise
  extends Promise<Vote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VoteType>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topic: <T = TopicPromise>() => T;
  comment: <T = CommentPromise>() => T;
  membership: <T = MembershipPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipConnection {
  pageInfo: PageInfo;
  edges: MembershipEdge[];
}

export interface MembershipConnectionPromise
  extends Promise<MembershipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MembershipEdge>>() => T;
  aggregate: <T = AggregateMembershipPromise>() => T;
}

export interface MembershipConnectionSubscription
  extends Promise<AsyncIterator<MembershipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MembershipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMembershipSubscription>() => T;
}

export interface MembershipEdge {
  node: Membership;
  cursor: String;
}

export interface MembershipEdgePromise
  extends Promise<MembershipEdge>,
    Fragmentable {
  node: <T = MembershipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MembershipEdgeSubscription
  extends Promise<AsyncIterator<MembershipEdge>>,
    Fragmentable {
  node: <T = MembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMembership {
  count: Int;
}

export interface AggregateMembershipPromise
  extends Promise<AggregateMembership>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMembershipSubscription
  extends Promise<AsyncIterator<AggregateMembership>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StationConnection {
  pageInfo: PageInfo;
  edges: StationEdge[];
}

export interface StationConnectionPromise
  extends Promise<StationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StationEdge>>() => T;
  aggregate: <T = AggregateStationPromise>() => T;
}

export interface StationConnectionSubscription
  extends Promise<AsyncIterator<StationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStationSubscription>() => T;
}

export interface StationEdge {
  node: Station;
  cursor: String;
}

export interface StationEdgePromise extends Promise<StationEdge>, Fragmentable {
  node: <T = StationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StationEdgeSubscription
  extends Promise<AsyncIterator<StationEdge>>,
    Fragmentable {
  node: <T = StationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStation {
  count: Int;
}

export interface AggregateStationPromise
  extends Promise<AggregateStation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStationSubscription
  extends Promise<AsyncIterator<AggregateStation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicConnection {
  pageInfo: PageInfo;
  edges: TopicEdge[];
}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopicPromise>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface TopicEdge {
  node: Topic;
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = TopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VoteConnection {
  pageInfo: PageInfo;
  edges: VoteEdge[];
}

export interface VoteConnectionPromise
  extends Promise<VoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoteEdge>>() => T;
  aggregate: <T = AggregateVotePromise>() => T;
}

export interface VoteConnectionSubscription
  extends Promise<AsyncIterator<VoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoteSubscription>() => T;
}

export interface VoteEdge {
  node: Vote;
  cursor: String;
}

export interface VoteEdgePromise extends Promise<VoteEdge>, Fragmentable {
  node: <T = VotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoteEdgeSubscription
  extends Promise<AsyncIterator<VoteEdge>>,
    Fragmentable {
  node: <T = VoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVote {
  count: Int;
}

export interface AggregateVotePromise
  extends Promise<AggregateVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoteSubscription
  extends Promise<AsyncIterator<AggregateVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MembershipSubscriptionPayload {
  mutation: MutationType;
  node: Membership;
  updatedFields: String[];
  previousValues: MembershipPreviousValues;
}

export interface MembershipSubscriptionPayloadPromise
  extends Promise<MembershipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MembershipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MembershipPreviousValuesPromise>() => T;
}

export interface MembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MembershipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MembershipPreviousValuesSubscription>() => T;
}

export interface MembershipPreviousValues {
  id: ID_Output;
  role: Role;
  state: MembershipState;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MembershipPreviousValuesPromise
  extends Promise<MembershipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<MembershipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<Role>>;
  state: () => Promise<AsyncIterator<MembershipState>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StationSubscriptionPayload {
  mutation: MutationType;
  node: Station;
  updatedFields: String[];
  previousValues: StationPreviousValues;
}

export interface StationSubscriptionPayloadPromise
  extends Promise<StationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StationPreviousValuesPromise>() => T;
}

export interface StationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StationPreviousValuesSubscription>() => T;
}

export interface StationPreviousValues {
  id: ID_Output;
  name: String;
  identifier?: String;
  description: String;
  public: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StationPreviousValuesPromise
  extends Promise<StationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StationPreviousValuesSubscription
  extends Promise<AsyncIterator<StationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  node: Topic;
  updatedFields: String[];
  previousValues: TopicPreviousValues;
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValuesPromise>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface TopicPreviousValues {
  id: ID_Output;
  title: String;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  identifier?: String;
  password: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VoteSubscriptionPayload {
  mutation: MutationType;
  node: Vote;
  updatedFields: String[];
  previousValues: VotePreviousValues;
}

export interface VoteSubscriptionPayloadPromise
  extends Promise<VoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotePreviousValuesPromise>() => T;
}

export interface VoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotePreviousValuesSubscription>() => T;
}

export interface VotePreviousValues {
  id: ID_Output;
  type: VoteType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VotePreviousValuesPromise
  extends Promise<VotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VoteType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VotePreviousValuesSubscription
  extends Promise<AsyncIterator<VotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VoteType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Station",
    embedded: false
  },
  {
    name: "Membership",
    embedded: false
  },
  {
    name: "Topic",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Vote",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "MembershipState",
    embedded: false
  },
  {
    name: "VoteType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
