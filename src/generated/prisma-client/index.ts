// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  membership: (where?: MembershipWhereInput) => Promise<boolean>;
  station: (where?: StationWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  membership: (where: MembershipWhereUniqueInput) => MembershipNullablePromise;
  memberships: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Membership>;
  membershipsConnection: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MembershipConnectionPromise;
  station: (where: StationWhereUniqueInput) => StationNullablePromise;
  stations: (args?: {
    where?: StationWhereInput;
    orderBy?: StationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Station>;
  stationsConnection: (args?: {
    where?: StationWhereInput;
    orderBy?: StationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StationConnectionPromise;
  topic: (where: TopicWhereUniqueInput) => TopicNullablePromise;
  topics: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Topic>;
  topicsConnection: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopicConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createMembership: (data: MembershipCreateInput) => MembershipPromise;
  updateMembership: (args: {
    data: MembershipUpdateInput;
    where: MembershipWhereUniqueInput;
  }) => MembershipPromise;
  updateManyMemberships: (args: {
    data: MembershipUpdateManyMutationInput;
    where?: MembershipWhereInput;
  }) => BatchPayloadPromise;
  upsertMembership: (args: {
    where: MembershipWhereUniqueInput;
    create: MembershipCreateInput;
    update: MembershipUpdateInput;
  }) => MembershipPromise;
  deleteMembership: (where: MembershipWhereUniqueInput) => MembershipPromise;
  deleteManyMemberships: (where?: MembershipWhereInput) => BatchPayloadPromise;
  createStation: (data: StationCreateInput) => StationPromise;
  updateStation: (args: {
    data: StationUpdateInput;
    where: StationWhereUniqueInput;
  }) => StationPromise;
  updateManyStations: (args: {
    data: StationUpdateManyMutationInput;
    where?: StationWhereInput;
  }) => BatchPayloadPromise;
  upsertStation: (args: {
    where: StationWhereUniqueInput;
    create: StationCreateInput;
    update: StationUpdateInput;
  }) => StationPromise;
  deleteStation: (where: StationWhereUniqueInput) => StationPromise;
  deleteManyStations: (where?: StationWhereInput) => BatchPayloadPromise;
  createTopic: (data: TopicCreateInput) => TopicPromise;
  updateTopic: (args: {
    data: TopicUpdateInput;
    where: TopicWhereUniqueInput;
  }) => TopicPromise;
  updateManyTopics: (args: {
    data: TopicUpdateManyMutationInput;
    where?: TopicWhereInput;
  }) => BatchPayloadPromise;
  upsertTopic: (args: {
    where: TopicWhereUniqueInput;
    create: TopicCreateInput;
    update: TopicUpdateInput;
  }) => TopicPromise;
  deleteTopic: (where: TopicWhereUniqueInput) => TopicPromise;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  membership: (
    where?: MembershipSubscriptionWhereInput
  ) => MembershipSubscriptionPayloadSubscription;
  station: (
    where?: StationSubscriptionWhereInput
  ) => StationSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC";

export type Role = "FOUNDER" | "ADMIN" | "MODERATOR" | "MEMBER";

export type MembershipState = "PENDING" | "ACTIVE" | "DETACHED" | "BANNED";

export type MembershipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC"
  | "state_ASC"
  | "state_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "identifier_ASC"
  | "identifier_DESC"
  | "description_ASC"
  | "description_DESC"
  | "public_ASC"
  | "public_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "identifier_ASC"
  | "identifier_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export type MembershipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MembershipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  station?: Maybe<StationWhereInput>;
  topics_every?: Maybe<TopicWhereInput>;
  topics_some?: Maybe<TopicWhereInput>;
  topics_none?: Maybe<TopicWhereInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  state?: Maybe<MembershipState>;
  state_not?: Maybe<MembershipState>;
  state_in?: Maybe<MembershipState[] | MembershipState>;
  state_not_in?: Maybe<MembershipState[] | MembershipState>;
  AND?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  OR?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  NOT?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  identifier?: Maybe<String>;
  identifier_not?: Maybe<String>;
  identifier_in?: Maybe<String[] | String>;
  identifier_not_in?: Maybe<String[] | String>;
  identifier_lt?: Maybe<String>;
  identifier_lte?: Maybe<String>;
  identifier_gt?: Maybe<String>;
  identifier_gte?: Maybe<String>;
  identifier_contains?: Maybe<String>;
  identifier_not_contains?: Maybe<String>;
  identifier_starts_with?: Maybe<String>;
  identifier_not_starts_with?: Maybe<String>;
  identifier_ends_with?: Maybe<String>;
  identifier_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  memberships_every?: Maybe<MembershipWhereInput>;
  memberships_some?: Maybe<MembershipWhereInput>;
  memberships_none?: Maybe<MembershipWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface StationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  identifier?: Maybe<String>;
  identifier_not?: Maybe<String>;
  identifier_in?: Maybe<String[] | String>;
  identifier_not_in?: Maybe<String[] | String>;
  identifier_lt?: Maybe<String>;
  identifier_lte?: Maybe<String>;
  identifier_gt?: Maybe<String>;
  identifier_gte?: Maybe<String>;
  identifier_contains?: Maybe<String>;
  identifier_not_contains?: Maybe<String>;
  identifier_starts_with?: Maybe<String>;
  identifier_not_starts_with?: Maybe<String>;
  identifier_ends_with?: Maybe<String>;
  identifier_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  public?: Maybe<Boolean>;
  public_not?: Maybe<Boolean>;
  members_every?: Maybe<MembershipWhereInput>;
  members_some?: Maybe<MembershipWhereInput>;
  members_none?: Maybe<MembershipWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StationWhereInput[] | StationWhereInput>;
  OR?: Maybe<StationWhereInput[] | StationWhereInput>;
  NOT?: Maybe<StationWhereInput[] | StationWhereInput>;
}

export interface TopicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  membership?: Maybe<MembershipWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  OR?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  NOT?: Maybe<TopicWhereInput[] | TopicWhereInput>;
}

export type StationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identifier?: Maybe<String>;
}>;

export type TopicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identifier?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  content: String;
}

export interface CommentUpdateInput {
  content?: Maybe<String>;
}

export interface CommentUpdateManyMutationInput {
  content?: Maybe<String>;
}

export interface MembershipCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface UserCreateOneWithoutMembershipsInput {
  create?: Maybe<UserCreateWithoutMembershipsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutMembershipsInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
}

export interface StationCreateOneWithoutMembersInput {
  create?: Maybe<StationCreateWithoutMembersInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
}

export interface TopicCreateManyWithoutMembershipInput {
  create?: Maybe<
    TopicCreateWithoutMembershipInput[] | TopicCreateWithoutMembershipInput
  >;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
}

export interface TopicCreateWithoutMembershipInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
}

export interface MembershipUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface UserUpdateOneRequiredWithoutMembershipsInput {
  create?: Maybe<UserCreateWithoutMembershipsInput>;
  update?: Maybe<UserUpdateWithoutMembershipsDataInput>;
  upsert?: Maybe<UserUpsertWithoutMembershipsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutMembershipsDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserUpsertWithoutMembershipsInput {
  update: UserUpdateWithoutMembershipsDataInput;
  create: UserCreateWithoutMembershipsInput;
}

export interface StationUpdateOneRequiredWithoutMembersInput {
  create?: Maybe<StationCreateWithoutMembersInput>;
  update?: Maybe<StationUpdateWithoutMembersDataInput>;
  upsert?: Maybe<StationUpsertWithoutMembersInput>;
  connect?: Maybe<StationWhereUniqueInput>;
}

export interface StationUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
}

export interface StationUpsertWithoutMembersInput {
  update: StationUpdateWithoutMembersDataInput;
  create: StationCreateWithoutMembersInput;
}

export interface TopicUpdateManyWithoutMembershipInput {
  create?: Maybe<
    TopicCreateWithoutMembershipInput[] | TopicCreateWithoutMembershipInput
  >;
  delete?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  connect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  set?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  disconnect?: Maybe<TopicWhereUniqueInput[] | TopicWhereUniqueInput>;
  update?: Maybe<
    | TopicUpdateWithWhereUniqueWithoutMembershipInput[]
    | TopicUpdateWithWhereUniqueWithoutMembershipInput
  >;
  upsert?: Maybe<
    | TopicUpsertWithWhereUniqueWithoutMembershipInput[]
    | TopicUpsertWithWhereUniqueWithoutMembershipInput
  >;
  deleteMany?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  updateMany?: Maybe<
    TopicUpdateManyWithWhereNestedInput[] | TopicUpdateManyWithWhereNestedInput
  >;
}

export interface TopicUpdateWithWhereUniqueWithoutMembershipInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutMembershipDataInput;
}

export interface TopicUpdateWithoutMembershipDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface TopicUpsertWithWhereUniqueWithoutMembershipInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutMembershipDataInput;
  create: TopicCreateWithoutMembershipInput;
}

export interface TopicScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  OR?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
  NOT?: Maybe<TopicScalarWhereInput[] | TopicScalarWhereInput>;
}

export interface TopicUpdateManyWithWhereNestedInput {
  where: TopicScalarWhereInput;
  data: TopicUpdateManyDataInput;
}

export interface TopicUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface MembershipUpdateManyMutationInput {
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  description: String;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipCreateManyWithoutStationInput>;
}

export interface MembershipCreateManyWithoutStationInput {
  create?: Maybe<
    MembershipCreateWithoutStationInput[] | MembershipCreateWithoutStationInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutStationInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationUpdateInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
  members?: Maybe<MembershipUpdateManyWithoutStationInput>;
}

export interface MembershipUpdateManyWithoutStationInput {
  create?: Maybe<
    MembershipCreateWithoutStationInput[] | MembershipCreateWithoutStationInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutStationInput[]
    | MembershipUpdateWithWhereUniqueWithoutStationInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutStationInput[]
    | MembershipUpsertWithWhereUniqueWithoutStationInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipUpdateWithWhereUniqueWithoutStationInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutStationDataInput;
}

export interface MembershipUpdateWithoutStationDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpsertWithWhereUniqueWithoutStationInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutStationDataInput;
  create: MembershipCreateWithoutStationInput;
}

export interface MembershipScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  state?: Maybe<MembershipState>;
  state_not?: Maybe<MembershipState>;
  state_in?: Maybe<MembershipState[] | MembershipState>;
  state_not_in?: Maybe<MembershipState[] | MembershipState>;
  AND?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  OR?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  NOT?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
}

export interface MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput;
  data: MembershipUpdateManyDataInput;
}

export interface MembershipUpdateManyDataInput {
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface StationUpdateManyMutationInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  public?: Maybe<Boolean>;
}

export interface TopicCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  membership: MembershipCreateOneWithoutTopicsInput;
}

export interface MembershipCreateOneWithoutTopicsInput {
  create?: Maybe<MembershipCreateWithoutTopicsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutTopicsInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutMembershipsInput;
  station: StationCreateOneWithoutMembersInput;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface TopicUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  membership?: Maybe<MembershipUpdateOneRequiredWithoutTopicsInput>;
}

export interface MembershipUpdateOneRequiredWithoutTopicsInput {
  create?: Maybe<MembershipCreateWithoutTopicsInput>;
  update?: Maybe<MembershipUpdateWithoutTopicsDataInput>;
  upsert?: Maybe<MembershipUpsertWithoutTopicsInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipUpdateWithoutTopicsDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutMembershipsInput>;
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpsertWithoutTopicsInput {
  update: MembershipUpdateWithoutTopicsDataInput;
  create: MembershipCreateWithoutTopicsInput;
}

export interface TopicUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  identifier?: Maybe<String>;
  password: String;
  email: String;
  memberships?: Maybe<MembershipCreateManyWithoutUserInput>;
}

export interface MembershipCreateManyWithoutUserInput {
  create?: Maybe<
    MembershipCreateWithoutUserInput[] | MembershipCreateWithoutUserInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface MembershipCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  station: StationCreateOneWithoutMembersInput;
  topics?: Maybe<TopicCreateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutUserInput>;
}

export interface MembershipUpdateManyWithoutUserInput {
  create?: Maybe<
    MembershipCreateWithoutUserInput[] | MembershipCreateWithoutUserInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    | MembershipUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    | MembershipUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipUpdateWithWhereUniqueWithoutUserInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutUserDataInput;
}

export interface MembershipUpdateWithoutUserDataInput {
  station?: Maybe<StationUpdateOneRequiredWithoutMembersInput>;
  topics?: Maybe<TopicUpdateManyWithoutMembershipInput>;
  role?: Maybe<Role>;
  state?: Maybe<MembershipState>;
}

export interface MembershipUpsertWithWhereUniqueWithoutUserInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutUserDataInput;
  create: MembershipCreateWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  identifier?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface MembershipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MembershipWhereInput>;
  AND?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  OR?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
}

export interface StationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StationWhereInput>;
  AND?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
  OR?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
  NOT?: Maybe<StationSubscriptionWhereInput[] | StationSubscriptionWhereInput>;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TopicWhereInput>;
  AND?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  OR?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  NOT?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Comment {
  id: ID_Output;
  content: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Membership {
  id: ID_Output;
  role: Role;
  state: MembershipState;
}

export interface MembershipPromise extends Promise<Membership>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
}

export interface MembershipSubscription
  extends Promise<AsyncIterator<Membership>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  station: <T = StationSubscription>() => T;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<AsyncIterator<Role>>;
  state: () => Promise<AsyncIterator<MembershipState>>;
}

export interface MembershipNullablePromise
  extends Promise<Membership | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  station: <T = StationPromise>() => T;
  topics: <T = FragmentableArray<Topic>>(args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
}

export interface User {
  id: ID_Output;
  name: String;
  identifier?: String;
  password: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  memberships: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Station {
  id: ID_Output;
  name: String;
  identifier?: String;
  description: String;
  public: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StationPromise extends Promise<Station>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  members: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StationSubscription
  extends Promise<AsyncIterator<Station>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  members: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StationNullablePromise
  extends Promise<Station | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  members: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Topic {
  id: ID_Output;
  title: String;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  membership: <T = MembershipPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  membership: <T = MembershipSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TopicNullablePromise
  extends Promise<Topic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  membership: <T = MembershipPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MembershipConnection {
  pageInfo: PageInfo;
  edges: MembershipEdge[];
}

export interface MembershipConnectionPromise
  extends Promise<MembershipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MembershipEdge>>() => T;
  aggregate: <T = AggregateMembershipPromise>() => T;
}

export interface MembershipConnectionSubscription
  extends Promise<AsyncIterator<MembershipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MembershipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMembershipSubscription>() => T;
}

export interface MembershipEdge {
  node: Membership;
  cursor: String;
}

export interface MembershipEdgePromise
  extends Promise<MembershipEdge>,
    Fragmentable {
  node: <T = MembershipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MembershipEdgeSubscription
  extends Promise<AsyncIterator<MembershipEdge>>,
    Fragmentable {
  node: <T = MembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMembership {
  count: Int;
}

export interface AggregateMembershipPromise
  extends Promise<AggregateMembership>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMembershipSubscription
  extends Promise<AsyncIterator<AggregateMembership>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StationConnection {
  pageInfo: PageInfo;
  edges: StationEdge[];
}

export interface StationConnectionPromise
  extends Promise<StationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StationEdge>>() => T;
  aggregate: <T = AggregateStationPromise>() => T;
}

export interface StationConnectionSubscription
  extends Promise<AsyncIterator<StationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStationSubscription>() => T;
}

export interface StationEdge {
  node: Station;
  cursor: String;
}

export interface StationEdgePromise extends Promise<StationEdge>, Fragmentable {
  node: <T = StationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StationEdgeSubscription
  extends Promise<AsyncIterator<StationEdge>>,
    Fragmentable {
  node: <T = StationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStation {
  count: Int;
}

export interface AggregateStationPromise
  extends Promise<AggregateStation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStationSubscription
  extends Promise<AsyncIterator<AggregateStation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicConnection {
  pageInfo: PageInfo;
  edges: TopicEdge[];
}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopicPromise>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface TopicEdge {
  node: Topic;
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = TopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  content: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface MembershipSubscriptionPayload {
  mutation: MutationType;
  node: Membership;
  updatedFields: String[];
  previousValues: MembershipPreviousValues;
}

export interface MembershipSubscriptionPayloadPromise
  extends Promise<MembershipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MembershipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MembershipPreviousValuesPromise>() => T;
}

export interface MembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MembershipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MembershipPreviousValuesSubscription>() => T;
}

export interface MembershipPreviousValues {
  id: ID_Output;
  role: Role;
  state: MembershipState;
}

export interface MembershipPreviousValuesPromise
  extends Promise<MembershipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  role: () => Promise<Role>;
  state: () => Promise<MembershipState>;
}

export interface MembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<MembershipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<Role>>;
  state: () => Promise<AsyncIterator<MembershipState>>;
}

export interface StationSubscriptionPayload {
  mutation: MutationType;
  node: Station;
  updatedFields: String[];
  previousValues: StationPreviousValues;
}

export interface StationSubscriptionPayloadPromise
  extends Promise<StationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StationPreviousValuesPromise>() => T;
}

export interface StationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StationPreviousValuesSubscription>() => T;
}

export interface StationPreviousValues {
  id: ID_Output;
  name: String;
  identifier?: String;
  description: String;
  public: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StationPreviousValuesPromise
  extends Promise<StationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  public: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StationPreviousValuesSubscription
  extends Promise<AsyncIterator<StationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  node: Topic;
  updatedFields: String[];
  previousValues: TopicPreviousValues;
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValuesPromise>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface TopicPreviousValues {
  id: ID_Output;
  title: String;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  identifier?: String;
  password: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  identifier: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  identifier: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Station",
    embedded: false
  },
  {
    name: "Membership",
    embedded: false
  },
  {
    name: "Topic",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "MembershipState",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
